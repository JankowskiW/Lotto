package pl.wj.lotto.domain.ticket.service;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import pl.wj.lotto.domain.common.drawdatetime.model.DrawDateTimeSettings;
import pl.wj.lotto.domain.common.drawdatetime.port.in.DrawDateTimeCheckerPort;
import pl.wj.lotto.domain.common.gametype.GameType;
import pl.wj.lotto.domain.common.gametype.GameTypeSettingsContainer;
import pl.wj.lotto.domain.common.notification.NotificationPort;
import pl.wj.lotto.domain.common.numbers.Numbers;
import pl.wj.lotto.domain.common.numbers.port.in.NumbersGeneratorPort;
import pl.wj.lotto.domain.common.numbers.port.in.NumbersValidatorPort;
import pl.wj.lotto.domain.ticket.model.Ticket;
import pl.wj.lotto.domain.ticket.model.dto.TicketRequestDto;
import pl.wj.lotto.domain.ticket.model.dto.TicketResponseDto;
import pl.wj.lotto.domain.ticket.port.out.TicketRepositoryPort;

import java.time.Clock;
import java.time.LocalDateTime;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.BDDMockito.given;

@ExtendWith(MockitoExtension.class)
class TicketServiceTest {
    @Mock
    private TicketRepositoryPort ticketRepositoryPort;
    @Mock
    private NotificationPort notificationPort;
    @Mock
    private DrawDateTimeCheckerPort drawDateTimeCheckerPort;
    @Mock
    private NumbersGeneratorPort numbersGeneratorPort;
    @Mock
    private NumbersValidatorPort numbersValidatorPort;
    @InjectMocks
    private TicketService ticketService;

    @Test
    void test() {
        Clock clock = Clock.systemDefaultZone();
        System.out.println(clock.getZone().getId());
    }

    @Test
    void shouldAddNewTicketWhenThereIsUserId() {
        // given
        GameType gameType = GameType.EJP;
        LocalDateTime generationDateTime = LocalDateTime.now();
        LocalDateTime nextDrawDateTime = LocalDateTime.now().plusDays(1);
        String userId = "some-user-id";
        String id = "some-id";
        TicketRequestDto ticketRequestDto = TicketRequestDto.builder()
                .userId(userId)
                .gameTypeId(gameType.getId())
                .numberOfDraws(1)
                .numbersAutogenerated(true)
                .build();
        List<Integer> mainNumbers = List.of(1,2,3,4,5,6);
        List<Integer> extraNumbers = List.of(1,2);
        Numbers numbers = Numbers.builder()
                .gameType(gameType)
                .drawDateTimeSettings(GameTypeSettingsContainer.getGameTypeSettings(gameType).drawDateTimeSettings())
                .mainNumbers(mainNumbers)
                .extraNumbers(extraNumbers)
                .build();
        TicketResponseDto expectedResult = TicketResponseDto.builder()
                .id(id)
                .userId(userId)
                .gameTypeName(gameType.getName())
                .numberOfDraws(1)
                .numbers(numbers)
                .generationDateTime(generationDateTime)
                .nextDrawDateTime(nextDrawDateTime)
                .build();
        given(numbersGeneratorPort.generate(any(GameType.class), anyBoolean())).willReturn(numbers);
        given(numbersValidatorPort.validate(any(Numbers.class))).willReturn(true);
        given(ticketRepositoryPort.save(any(Ticket.class))).willAnswer(
                i -> {
                    Ticket t = i.getArgument(0, Ticket.class);
                    t.setId(id);
                    t.setGenerationDateTime(generationDateTime);
                    return t;
                });
        given(drawDateTimeCheckerPort.getNextDrawDateTime(any(DrawDateTimeSettings.class))).willReturn(nextDrawDateTime);

        // when
        TicketResponseDto result = ticketService.addTicket(ticketRequestDto);

        // then
        assertThat(result)
                .usingRecursiveComparison()
                .isEqualTo(expectedResult);
    }

    @Test
    void shouldThrowExceptionWhenGivenNumbersAreInvalid() {
        // given
        GameType gameType = GameType.LOTTO;
        String userId = "some-user-id";
        List<Integer> invalidMainNumbers = List.of(1,2,3,4,5,6,7);
        TicketRequestDto ticketRequestDto = TicketRequestDto.builder()
                .userId(userId)
                .gameTypeId(gameType.getId())
                .numberOfDraws(1)
                .numbersAutogenerated(false)
                .mainNumbers(invalidMainNumbers)
                .build();
        given(numbersValidatorPort.validate(any(Numbers.class))).willReturn(false);

        // when && then
        assertThatThrownBy(() -> ticketService.addTicket(ticketRequestDto))
                .isInstanceOf(RuntimeException.class)
                .hasMessage("Given numbers are invalid");
    }
}